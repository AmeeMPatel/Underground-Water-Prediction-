import cv2
from cvzone.HandTrackingModule import HandDetector
import numpy as np
import pyautogui
import time

# Initialize the video capture
cap = cv2.VideoCapture(0)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1480)  # Set width
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 920)  # Set height

# Initialize the hand detector
detector = HandDetector(detectionCon=0.8, maxHands=1)

# Expanded list of keys including numbers, symbols, space, and enter key
keys = [
    ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'],
    ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
    ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ';'],
    ['Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', '/'],
    ['!', '@', '#', '$', '%', '^', '&', '*', '(', ')'],
    [' ', 'Enter']  # Space and Enter in the last row
]

# Keyboard layout dimensions
button_width, button_height = 100, 100  # Key size
key_spacing = 10  # Space between keys
keyboard_x, keyboard_y = 50, 50  # Starting position of keyboard

# Open the text file in write mode
with open("I37A47.txt", "w") as file:
    last_key = None
    last_time = 0
    debounce_time = 0.5  # Debounce time in seconds

    # Function to draw the virtual keyboard
    def draw_keyboard(img, keys, button_width, button_height, keyboard_x, keyboard_y, active_key=None):
        for row_idx, row in enumerate(keys):
            for key_idx, key in enumerate(row):
                x = keyboard_x + key_idx * (button_width + key_spacing)
                y = keyboard_y + row_idx * (button_height + key_spacing)

                if key == ' ':
                    # Draw space bar
                    cv2.rectangle(img, (x, y), (x + button_width * 6 + key_spacing * 5, y + button_height), (128, 0, 128), cv2.FILLED)
                    cv2.rectangle(img, (x, y), (x + button_width * 6 + key_spacing * 5, y + button_height), (255, 255, 255), 2)
                elif key == 'Enter':
                    # Draw Enter key
                    cv2.rectangle(img, (x, y), (x + button_width * 2 + key_spacing, y + button_height), (128, 0, 128), cv2.FILLED)
                    cv2.rectangle(img, (x, y), (x + button_width * 2 + key_spacing, y + button_height), (255, 255, 255), 2)
                    # Draw "Enter" text
                    cv2.putText(img, 'Enter', (x + 10, y + 60), cv2.FONT_HERSHEY_SIMPLEX, 1.5, (255, 255, 255), 2)
                else:
                    # Draw regular keys
                    color = (128, 0, 128)  # Purple color for keys
                    border_color = (255, 255, 255)  # White color for borders

                    # Draw key background
                    cv2.rectangle(img, (x, y), (x + button_width, y + button_height), color, cv2.FILLED)
                    cv2.rectangle(img, (x, y), (x + button_width, y + button_height), border_color, 2)

                    # Highlight active key
                    if active_key == key:
                        cv2.rectangle(img, (x, y), (x + button_width, y + button_height), (0, 255, 0), cv2.FILLED)

                    # Draw key text
                    cv2.putText(img, key, (x + 20, y + 60), cv2.FONT_HERSHEY_SIMPLEX, 1.5, (255, 255, 255), 2)

    # Function to detect which key is being pressed
    def detect_key_pressed(lmList, keys, button_width, button_height, keyboard_x, keyboard_y):
        if lmList:
            for row_idx, row in enumerate(keys):
                for key_idx, key in enumerate(row):
                    x = keyboard_x + key_idx * (button_width + key_spacing)
                    y = keyboard_y + row_idx * (button_height + key_spacing)

                    if key == ' ':
                        # Check space bar area
                        if x < lmList[8][0] < x + button_width * 6 + key_spacing * 5 and y < lmList[8][1] < y + button_height:
                            return ' '  # Return space key
                    elif key == 'Enter':
                        # Check Enter key area
                        if x < lmList[8][0] < x + button_width * 2 + key_spacing and y < lmList[8][1] < y + button_height:
                            return 'Enter'  # Return Enter key
                    else:
                        # Check regular key area
                        if x < lmList[8][0] < x + button_width and y < lmList[8][1] < y + button_height:
                            return key
        return None

    # Gesture detection function (checks if index finger is bent)
    def detect_click_gesture(lmList):
        if lmList:
            if len(lmList) >= 11:  # Ensure enough landmarks are detected
                finger_base = lmList[6]
                finger_tip = lmList[8]
                finger_middle = lmList[10]
                # Calculate angle using vector mathematics
                v1 = np.array([finger_base[0] - finger_middle[0], finger_base[1] - finger_middle[1]])
                v2 = np.array([finger_tip[0] - finger_middle[0], finger_tip[1] - finger_middle[1]])
                angle = np.degrees(np.arccos(np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))))
                # Angle threshold to detect finger bend (adjust as needed)
                angle_threshold = 100
                if angle < angle_threshold:
                    return True
        return False

    # Main loop
    while True:
        success, img = cap.read()
        if not success:
            break  # Exit the loop if the frame was not captured successfully
        
        # Detect hands in the image
        hands, img = detector.findHands(img)
        
        # Get the list of landmarks and bounding box info
        lmList = None
        if hands:
            lmList = hands[0]['lmList']  # List of 21 Landmark points
        
        # Draw the keyboard
        active_key = None
        if lmList:
            active_key = detect_key_pressed(lmList, keys, button_width, button_height, keyboard_x, keyboard_y)
        draw_keyboard(img, keys, button_width, button_height, keyboard_x, keyboard_y, active_key)
        
        # Detect click gesture and type into application
        if detect_click_gesture(lmList):
            current_time = time.time()
            if active_key and (last_key != active_key or (current_time - last_time) > debounce_time):
                if active_key == 'Enter':
                    file.write('\n')  # Write newline to the text file for Enter key
                    pyautogui.press('enter')  # Simulate pressing Enter key
                else:
                    pyautogui.press(active_key)  # Simulate typing the key
                    file.write(active_key)  # Write the key to the text file
                last_key = active_key
                last_time = current_time
        
        # Display the image
        cv2.imshow("Virtual Keyboard", img)
        
        # Exit loop when 'q' key is pressed
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

# Release the camera and close all OpenCV windows
cap.release()
cv2.destroyAllWindows()


